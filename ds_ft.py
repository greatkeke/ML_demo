# -*- coding: utf-8 -*-
"""ds_ft.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SJ_f4NHxHbGZtZESOfceGIcgbdJ9-J1k
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install unsloth
# !pip install --force-reinstall --no-cache-dir --no-deps git+https://github.com/unslothai/unsloth.git
#

# !pip install --upgrade transformers peft

from huggingface_hub import login
from google.colab import userdata

hf_token = userdata.get('HF_TOKEN')

login(hf_token)

# 导入wandb库 - Weights & Biases，用于机器学习实验跟踪和可视化
import wandb

wb_token = userdata.get('WB_TOKEN')

wandb.login(key=wb_token)
run = wandb.init(
    project='Fine-tune-DeepSeek-R1-Distill-Llama-8B sentiment',    # 设置项目名称 - 这里是用于SQL分析的DeepSeek模型微调项目
    job_type="training",
    anonymous="allow"# 允许匿名访问 # "allow"表示即使没有wandb账号的用户也能查看这个项目
)

# 从unsloth库中导入FastLanguageModel类
# unsloth是一个优化的语言模型加载和训练库
from unsloth import FastLanguageModel

# 设置模型参数
# 最大序列长度，即模型能处理的最大token数量
max_seq_length = 2048
dtype = None # 数据类型设置为None，让模型自动选择合适的数据类型
load_in_4bit = True # 启用4bit量化加载 # 4bit量化可以显著减少模型内存占用，但可能略微影响模型性能

# 加载预训练模型和分词器
model, tokenizer = FastLanguageModel.from_pretrained(
    model_name = "unsloth/DeepSeek-R1-Distill-Llama-8B",
    max_seq_length = max_seq_length,     # 设置最大序列长度
    dtype = dtype,# 设置数据类型
    load_in_4bit = load_in_4bit,  # 启用4bit量化加载
    token = hf_token, # 使用Hugging Face的访问令牌
)

from google.colab import drive
drive.mount('/content/drive')

prompt = """Below is a comment. Analyze the sentiment of the comment directly.

### Comment:
Ooo duck congee my favourite. The oysters looked scrumptious but the pee pee soup, I’m sorry. Today’s video was great, thank you Amy.

### Response:
"""

# 将模型切换到推理模式
FastLanguageModel.for_inference(model)
# 对输入文本进行分词和编码
# [prompt] - 将prompt放入列表中，因为tokenizer期望批处理输入
# return_tensors="pt" - 返回PyTorch张量格式
# to("cuda") - 将张量移动到GPU上进行计算
inputs = tokenizer([prompt], return_tensors="pt").to("cuda")

# 使用模型生成响应
outputs = model.generate(
    input_ids=inputs.input_ids,
    attention_mask=inputs.attention_mask,
    max_new_tokens=1200,
    use_cache=True,
)
# 后处理生成的输出
# batch_decode - 将标记ID序列解码回文本
# split("### Response:")[1] - 提取"### Response:"之后的部分，即模型的实际回答
response = tokenizer.batch_decode(outputs)
print(response[0].split("### Response:")[1])


#微调前：模型能给出情感分析，但是太啰嗦

train_prompt_style = """Below is an instruction that describes a task,
paired with an input that provides further context.
Write a response directly without any thinking.

### Instruction:
You are a sentiment expert with advance understanding of video comments.
You can understand sentiment from the comment.
Think like sentiment expert and generate result of the comment.

### Comment:
{}

### Response:
{}"""

from datasets import load_dataset
# 使用公开的数据源，结果中仅包含（neg|pos|nut)
ds = load_dataset("Sp1786/multiclass-sentiment-analysis-dataset")

# 检查数据
print(ds['validation'][:1])
dataset = ds['test'][:25]
print(dataset['text'][:1])
print(dataset['label'][:1])
print(dataset['sentiment'][:1])

EOS_TOKEN = tokenizer.eos_token  # Must add EOS_TOKEN

# 风格化，用于训练调整
def format_prompt(examples):
    inputs = examples["text"] # 使用 text 作为输入
    outputs = examples["sentiment"] # 使用 sentiment 作为输出

    texts = []
    for input, output in zip(inputs, outputs):
        text = train_prompt_style.format(input, output) + EOS_TOKEN
        texts.append(text)
    return texts

FastLanguageModel.for_training(model)
model = FastLanguageModel.get_peft_model(
    model,
    r=16,   # LoRA的秩(rank)值，决定了低秩矩阵的维度，较大的r值(如16)可以提供更强的模型表达能力，但会增加参数量和计算开销，较小的r值(如4或8)则会减少参数量，但可能影响模型性能，通常在4-16之间选择,需要在性能和效率之间权衡
    target_modules=[ #指定需要应用LoRA微调的模块列表，q_proj, k_proj, v_proj: 注意力机制中的查询、键、值投影层
        "q_proj",
        "k_proj",
        "v_proj",
        "o_proj", #注意力输出投影层
        "gate_proj",
        "up_proj",
        "down_proj",
    ],
    lora_alpha=16, #缩放参数，用于控制LoRA更新的强度，通常设置为与r相同的值，较大的alpha会增加LoRA的影响力，较小的alpha则会减弱LoRA的影响
    lora_dropout=0, #LoRA层的dropout率，0表示不使用dropout，增加dropout可以帮助防止过拟合，但可能影响训练稳定性，在微调时通常设为0或很小的值
    bias="none", #是否微调偏置项，"none"表示不微调偏置参数，也可以设置为"all"或"lora_only"来微调不同范围的偏置
    use_gradient_checkpointing="unsloth",  # 梯度检查点策略，"unsloth"是一种优化的检查点策略，适用于长上下文可以显著减少显存使用，但会略微增加计算时间对处理长文本特别有用
    random_state=3407, #随机数种子，控制初始化的随机性，固定种子可以确保实验可重复性
    use_rslora=False, #是否使用RSLoRA(Rank-Stabilized LoRA) False表示使用标准LoRARSLoRA是一种改进的LoRA变体，可以提供更稳定的训练
    loftq_config=None, #LoftQ配置None表示不使用LoftQ量化LoftQ是一种用于模型量化的技术，可以减少模型大小
)

print(dataset)

from trl import SFTTrainer
from transformers import TrainingArguments, Trainer
from unsloth import is_bfloat16_supported

trainer = SFTTrainer(
    model=model,
    tokenizer=tokenizer,
    train_dataset=ds['train'],
    eval_dataset=ds['test'],
    formatting_func=format_prompt,
    max_seq_length=max_seq_length,
    dataset_num_proc=2,
    ## 训练参数配置
    args=TrainingArguments(
        # 批处理相关
        per_device_train_batch_size=2, # 每个设备（GPU）的训练批次大小
        gradient_accumulation_steps=4,# 梯度累积步数，用于模拟更大的批次大小
         # 训练步数和预热
        warmup_steps=5,# 学习率预热步数，逐步增加学习率
        max_steps=60,# 最大训练步数
        learning_rate=2e-4,
        fp16=not is_bfloat16_supported(), # 如果不支持 bfloat16，则使用 float16
        bf16=is_bfloat16_supported(),# 如果支持则使用 bfloat16，通常在新型 GPU 上性能更好
        logging_steps=10,# 每10步记录一次日志
        optim="adamw_8bit", # 使用8位精度的 AdamW 优化器
        weight_decay=0.01,# 权重衰减率，用于防止过拟合
        lr_scheduler_type="linear",# 学习率调度器类型，使用线性衰减
        seed=3407,# 随机种子，确保实验可重复性
        output_dir="outputs", # 模型和检查点的输出目录
    ),
)

trainer_stats = trainer.train()

# 定义提示模板
prompt_style = """Below is an instruction that describes a task,
paired with an input that provides further context.
Write a response directly without any thinking.

### Instruction:
You are a sentiment expert with advance understanding of video comments.
You can understand sentiment from the comment.
Think like sentiment expert and generate result of the comment.

### Comment:
{}

### Response:
{}"""

# 定义测试用的 text
comment1 = """
Ooo duck congee my favourite. The oysters looked scrumptious but the pee pee soup, I’m sorry. Today’s video was great, thank you Amy.
"""

# 将模型设置为推理模式
FastLanguageModel.for_inference(model)
# 准备输入数据
# 使用提示模板格式化查询，并转换为模型可处理的张量格式
inputs = tokenizer([prompt_style.format(comment1, "")], return_tensors="pt").to("cuda")

# 生成响应
outputs = model.generate(
    input_ids=inputs.input_ids, # 输入的标记ID
    attention_mask=inputs.attention_mask, # 注意力掩码，用于处理填充
    max_new_tokens=1200, # 最大生成的新标记数
    use_cache=True,  # 使用缓存以提高生成速度
)
# 解码模型输出
# 使用分词器将输出转换回文本，并提取Response部分
response = tokenizer.batch_decode(outputs)
print(response[0].split("### Response:")[1])

#微调后：得到准确且精炼的分析结果

local_path="deepseek_nlp_model2"

model.save_pretrained(local_path)
tokenizer.save_pretrained(local_path)

# Save merged model
# model.save_pretrained_merged(local_path, tokenizer, save_method="merged_16bit")

model.push_to_hub(local_path)
tokenizer.push_to_hub(local_path)

from google.colab import drive
drive.mount('/content/drive')
drive_path = "/content/drive/MyDrive/deepseek_nlp_model2"
model.save_pretrained(drive_path)
tokenizer.save_pretrained(drive_path)

import pandas as pd


# Load the dataset
comments = pd.read_csv("/content/drive/MyDrive/video_comments.csv")

# Print some info (optional)
print(comments[:5])

from tqdm import tqdm
import time
import pandas as pd

# Assuming 'comments' DataFrame is already loaded and processed as in the original code

# Process each formatted comment with tqdm progress bar
for index, comment in tqdm(comments.iterrows(), total=len(comments), desc="Analyzing sentiments"):
    inputs = tokenizer([prompt_style.format(comment['commentText'], "")], return_tensors="pt").to("cuda")
    outputs = model.generate(
        input_ids=inputs.input_ids,
        attention_mask=inputs.attention_mask,
        max_new_tokens=1200,
        use_cache=True,
    )
    response = tokenizer.batch_decode(outputs)
    comments.at[index,'sentiment'] = response[0].split("### Response:")[1].split("<｜end▁of▁sentence｜>")[0] # Extract sentiment directly

comments.to_csv("/content/drive/MyDrive/video_comments_sentiment_0217.csv")